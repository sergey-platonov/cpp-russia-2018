Параллельное программирование - тема очень многогранная и глубокая. За десятки лет исследований было выработано огромное количество подходов, практик и инструментов, но вряд ли мы можем считать, что язык C++ успевал за этими тенденциями. Начиная со стандарта C++11, были введены такие концепции как std::thread, std::atomic, std::future, std::mutex, а в будущем ожидается, что будут добавлены coroutines - модель асинхронных вычислений. Что ж, это все интересные вещи для изучения, - но речь в докладе пойдет о совершенно иной идее.

Software Transactional Memory (STM) - концепция транзакционно изменяемой модели данных - существует уже давно и имеет ряд реализаций для всех языков. С помощью STM вы выражаете свою модель данных, и запускаете ее на изменение в нескольких потоках, конкурентно, при этом вам не нужно беспокоиться о синхронизации потоков, о валидном состоянии данных, о блокировках. STM сделает все за вас. Звучит это очень хорошо, однако не все STM-библиотеки одинаково полезны. Традиционные императивные STM очень сложно устроены, подвержены нетривиальным многопоточным багам, и их трудно использовать. С другой стороны, в мире функционального программирования уже давно существует концепция комбинаторной STM, транзакции в которой являются компонуемыми кирпичиками, из которых вы строите транзакции более высокого уровня. Комбинаторный подход к STM позволяет выражать конкурентную модель данных более гибко, понятно и надежно. Параллельное программирование тоже может быть приятным!

В докладе я расскажу об особенностях комбинаторной STM, как ее использовать, и как ее можно реализовать в С++17.
